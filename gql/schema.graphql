# import Role, BillingType, CloudProvider, UpdateMethod, OperationType, ServiceType from "./generated/prisma.graphql"

scalar DateTime
scalar Json
scalar Integer
scalar Float
scalar Upload

# directives
directive @private on QUERY | FIELD | FIELD_DEFINITION | MUTATION
directive @isAuthenticated on QUERY | FIELD | FIELD_DEFINITION | MUTATION
directive @hasPermissions(permissions: [String]) on QUERY | FIELD | FIELD_DEFINITION | MUTATION

type Query {
  info: String!
  users: [User!]!
  roles: [Role]! @isAuthenticated @hasPermissions(permissions: ["SYSTEM_MANAGE_ROLES"])
  products: [Product]!
  productsForService(service: ServiceType! active: Boolean): [Product]!

  # keybot service queries
  ownedKeybotServices: [KeybotService]! @isAuthenticated
  ownedKeybotService(serviceId: String!): [KeybotService]! @isAuthenticated
  keybotServiceCredentials(serviceId: String!): [KeybotCredentials]! @isAuthenticated
  keybotCustomFiles(serviceId: String!): OperationResponse! @isAuthenticated
}

type Mutation {
  createUser(email: String!, password: String!, name: String!): User!
  registerUser(email: String!, password: String!, name: String!): AuthPayload!
  sendEmailActivation: OperationResponse! @isAuthenticated
  verifyAccount(token: String!): OperationResponse! @isAuthenticated
  login(email: String!, password: String!): AuthPayload!
  
  createRole(name: String!, permissions: String): Role!
  updateRole(id: ID!, name: String, permissions: String): Role!
  deleteRole(id: ID!): OperationResponse!

  # Keybot service mutations
  createKeybotService(name: String!, updateType: UpdateMethod!): OperationResponse! @isAuthenticated
  uploadCustomFile(file: Upload!, filePath: String!, fileType: String!, viewPath: String, serviceId: String!): OperationResponse! @isAuthenticated
  deleteCustomFile(serviceId: String!, filePath: String!): OperationResponse! @isAuthenticated
  deployService(id: String!): OperationResponse! @isAuthenticated

  # updateKeybotCredentials(serviceId: String!, production: Boolean!, sessionSecret: String!, mongoUrl: String!, discordToken: String!, encryptionKey: String!): KeybotCredentials! @isAuthenticated
  updateKeybotCredentials(serviceId: String!, data: Json!): OperationResponse! @isAuthenticated
}

type User {
  id: ID!
  createdAt: DateTime!
  email: String!
  activated: Boolean!
  activationKey: String
  salt: String! @private
  password: String! @private
  name: String!
  roles: [Role]
  billingPlans: [BillingPlan]
}

type BillingPlan {
  id: ID!
  createdAt: DateTime!
  associatedProducts: [Product]!
  forUser: User!
}

type Product {
  id: ID!
  createdAt: DateTime! @private
  title: String!
  active: Boolean!
  description: String
  features: [String!]!
  price: Float!
  price_currency: String!
  priceFluctuates: Boolean
  billingType: BillingType
  forService: ServiceType!
  serviceRestrictions: Json
  requiresContact: Boolean!
}

type KeybotService {
  id: ID!
  name: String!
  createdAt: DateTime! @private
  owner: User!
  cloudProvider: CloudProvider!
  cloudResourceId: String @private
  currentOperation: OperationType
  currentOperationStatus: String
  currentVersion: String
  lastDeploy: DateTime
  updateType: UpdateMethod
  credentials: KeybotCredentials
  customFiles: Json
}

type KeybotCredentials {
  id: ID!
  forService: KeybotService!
  createdAt: DateTime!
  production: Boolean
  sessionSecret: String!
  mongoUrl: String!
  discordToken: String!
  encryptionKey: String!
}

type OperationResponse {
  resourceId: ID
  status: Integer!
  error: String
  message: String
}

type AuthPayload {
  error: String
  token: String
  isAdmin: Boolean
  user: User
}